/*
* So, this works like this:
*
* When user location changes, app sets a location in the ocean. We track changes in the ocean and when there is a change,
* we create a pool from strach everytime (it's cheap) and set it to /pools/$uid where child of this ref is $mid (a user key).
* The key point here is we *MUST* do this with user privileges so we don't override the rules here.
* Logic of the pool is these rules. We check if that user is OK by the current user filters, blocked and matched statuses on write()
* Since write fails immediately for "unfit" profiles, we don't even need to check filters/conditions anywhere else.
* Code here is a bit ugly but that's because we are using a hacky language (Bolt) and a hacky technique.
* The app caches loop keys and question keys so they don't download it everytime.
*/


path /pools/{uid}/{mid} {
  write() {
    isCurrentUser(uid)
    && isNotSelf(mid) // We shouldn't users themselves to their pool
    && !isBlocked(mid)
    && !isMatched(mid)
    //@&& !isSeenCurrentQuestion(mid)
    && checkGenderFilterFor(mid)
    && checkAgeFilterFor(mid)
  }
}

getFilterOptionForCU(option) { root.users.filters[currentUser()][option] }
getSummaryForPI(user) { root.users.summary[user] }

getAgeFor(mid) { getSummaryForPI(mid).age }
getGenderFor(mid) { getSummaryForPI(mid).gender }
getNetworkFor(mid) { getSummaryForPI(mid).network }

checkGenderFilterFor(mid) {
  getFilterOptionForCU('gender') == 'both' || getFilterOptionForCU('gender') == getGenderFor(mid)
}

checkAgeMin(mid) { getAgeFor(mid) >= getFilterOptionForCU('ageMin') }
checkAgeMax(mid) { getAgeFor(mid) <= getFilterOptionForCU('ageMax') }

checkAgeFilterFor(mid) { checkAgeMin(mid) && checkAgeMax(mid) }

isSeenCurrentQuestion(mid) {
  root.users.questions[getSummaryForPI(mid).current_question_id].seen_by[currentUser()] == true
}

type PoolItem extends Object {}
