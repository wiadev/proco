/*
* So, this works like this:
*
* App loads the nearby ids and pushes them to /pools/$uid/$key ($key is the other user here)
* We check if that user is OK by the current user filters, blocked and matched statuses in here, on write()
* Since write fails immediately for "unfit" profiles, we don't even need to check filters/conditions anywhere else.
* Code here is a bit ugly but that's because we are using a hacky language (Bolt) and a hacky technique.
* On successful writes a cloud functions triggeres and gets user loop links, question & answer.
*/


path /pools/{uid}/{mid} is PoolItem {
  write() {
    isCurrentUser(uid) &&
    !isBlocked(mid) &&
    !isMatched(mid) &&
    !isSeenCurrentQuestion(mid) &&
    checkGenderFilterFor(mid) &&
    checkAgeFilterFor(mid)
  }
}

getFilterOptionForCU(option) { root.users.filters[currentUser()][option] }
getSummaryForPI(user) { root.users.summary[user] }

getAgeFor(mid) { getSummaryForPI(mid).age }
getGenderFor(mid) { getSummaryForPI(mid).gender }
getNetworkFor(mid) { getSummaryForPI(mid).network }

checkGenderFilterFor(mid) {
  getFilterOptionForCU('gender') == 'Both' || getFilterOptionForCU('gender') == getGenderFor(mid)
}

checkAgeMin(mid) { getAgeFor(mid) >= getFilterOptionForCU('ageMin') }
checkAgeMax(mid) { getAgeFor(mid) <= getFilterOptionForCU('ageMax') }

checkAgeFilterFor(mid) { checkAgeMin(mid) && checkAgeMax(mid) }

isSeenCurrentQuestion(mid) {
  root.users.questions[getSummaryForPI(mid).current_question_id].seen_by[currentUser()] == true
}

type PoolItem extends Object {

}
